# 220430 Study Group : Concurrent

- 아키텍처(구조) : 웹브라우저 → (HTTP) → 서버 → DB로 이어지는, 대다수 웹서비스의 구조.
- 나머지는 동시성(Concurrent) 문제 등, 웹서비스 이용에서 발생하는 문제를 어떻게 해결하는가에 대한 것.

# 1. 운영체제(OS)

- 특수한 목적의 **프로그램**
    - ↔ 응용 프로그램(운영체제가 있다는 것을 전제로 굴러감)
1. **하드웨어**를 관리 : 마우스, 키보드, HDD, 메모리, CPU 등
    - 각 하드웨어(부품)에 대한 로직을 관리 → **다양한 제품**에 대응
    - RAM의 용량 등 **리소스**를 관리 → 여러 프로그램에게 분배해서 동시 구동
2. 운용프로그램과 하드웨어 사이에서 **인터페이스** 역할
    - 간략하게 말해서, 중재자 역할
3. 프로세스(실행된 프로그램을 의미, 메모리 상에 떠 있음)를 관리 = **스케줄링(scheduling)**
    - CPU는 한번에 하나씩밖에 실행하지 못함에도, 마치 여러 프로세스를 동시에 실행되는 것**처럼** 보이게 함. = **Concurrent**(**동시성**)
    - 스케줄링 알고리즘 : CPU를 효율적으로 사용하여, 연산을 쉬게 하지 않기 위한 알고리즘.
        - 네트워크/HDD/DB 등에 접속하는 연산을 프로세스가 실행 중일 때는 CPU가 상대적으로 너무 빨라서 노는 시간이 길어지기 때문.
- Pointer(C 등의 주소 검색)로 다른 응용프로그램이 점유하는 메모리에 접근하는 것을 차단
- 시스템의 동작을 제어하는 시스템 소프트웨어

# 2. 동시성으로 인해 발생하는 문제(동시성 문제)

- 공통된 외부 자원(resource … 데이터베이스 등)을 동시에 사용할 때 일어나는 문제.
- 돈 복사 등의 문제가 발생하는 원인
- **(Mutex) Lock** : 먼저 온 처리가 끝날 때까지 다른 처리가 되지 않도록 잠그는 것.
    - 동시성을 관리하기 위한 가장 좋은 방법(특히 은행 등 정확성이 필요할 때)
- 방어 로직(exception check 등) : 혹시 모르니까 한 줄 추가해 놓은 것.
    - 여차하면 에러 내고 처리 종료하는 것이 좋은 프로그램의 미덕.
    - 게임 등 정확성을 희생하더라도 에러를 적게 할 필요가 있을 땐 방어 로직을 희생하기도 함.